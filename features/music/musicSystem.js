import { 
    AudioPlayerStatus,
    createAudioPlayer,
    createAudioResource,
    joinVoiceChannel,
    VoiceConnectionStatus,
    entersState
} from '@discordjs/voice';
import { EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle } from 'discord.js';
import ytdl from '@distube/ytdl-core';
import { search } from 'youtube-search-without-api-key';

// Mapa para almacenar los reproductores de m√∫sica por servidor
const guildPlayers = new Map();
// Mapa para almacenar las colas de reproducci√≥n por servidor
const guildQueues = new Map();

// Constantes para emojis y colores
const EMOJIS = {
    PLAY: '‚ñ∂Ô∏è',
    PAUSE: '‚è∏Ô∏è',
    SKIP: '‚è≠Ô∏è',
    STOP: '‚èπÔ∏è',
    QUEUE: 'üìã',
    LEAVE: 'üëã',
    MUSIC: 'üéµ',
    TIME: '‚è±Ô∏è',
    USER: 'üë§',
    VOLUME: 'üîä',
    ADDED: '‚úÖ',
    ERROR: '‚ùå',
    NOW_PLAYING: 'üéß',
    NEXT: '‚è©',
    REPEAT: 'üîÅ',
    WAVE: '„Ä∞Ô∏è',
    NOTES: ['üéµ', 'üé∂', 'üéº', 'üéπ', 'üé∏', 'üé∫', 'ü•Å', 'üéª']
};

const COLORS = {
    PRIMARY: 0x0099FF,
    SUCCESS: 0x00FF00,
    ERROR: 0xFF0000,
    WARNING: 0xFFAA00
};

/**
 * Obtiene o crea un reproductor de m√∫sica para un servidor
 * @param {string} guildId - ID del servidor
 * @returns {Object} Objeto con el reproductor y la cola
 */
function getOrCreatePlayer(guildId) {
    let playerData = guildPlayers.get(guildId);
    let queueData = guildQueues.get(guildId);

    if (!playerData) {
        playerData = {
            player: createAudioPlayer(),
            connection: null,
            currentTrack: null,
            isPlaying: false,
            lastVoiceChannel: null
        };
        guildPlayers.set(guildId, playerData);
    }

    if (!queueData) {
        queueData = {
            tracks: [],
            currentTrack: null,
            nowPlayingMessage: null
        };
        guildQueues.set(guildId, queueData);
    }

    return { playerData, queueData };
}

/**
 * Busca una canci√≥n en YouTube
 * @param {string} query - T√©rmino de b√∫squeda
 * @returns {Promise<Object>} Informaci√≥n de la canci√≥n
 */
async function searchSong(query) {
    try {
        const results = await search(query);
        if (!results || results.length === 0) {
            throw new Error('No se encontraron resultados.');
        }
        return results[0];
    } catch (error) {
        console.error('[Music System] Error al buscar canci√≥n:', error);
        throw error;
    }
}

/**
 * Crea un recurso de audio a partir de una URL de YouTube
 * @param {string} url - URL del video
 * @returns {Promise<Object>} Recurso de audio
 */
async function createYouTubeResource(url) {
    try {
        const stream = ytdl(url, {
            filter: 'audioonly',
            quality: 'highestaudio',
            highWaterMark: 1 << 25
        });
        return createAudioResource(stream);
    } catch (error) {
        console.error('[Music System] Error al crear recurso de audio:', error);
        throw error;
    }
}

/**
 * Conecta el bot a un canal de voz
 * @param {Object} channel - Canal de voz
 * @param {string} guildId - ID del servidor
 * @returns {Object} Conexi√≥n de voz
 */
async function connectToChannel(channel, guildId) {
    const connection = joinVoiceChannel({
        channelId: channel.id,
        guildId: channel.guild.id,
        adapterCreator: channel.guild.voiceAdapterCreator,
    });

    try {
        await entersState(connection, VoiceConnectionStatus.Ready, 30_000);

        // Configurar eventos de la conexi√≥n
        connection.on(VoiceConnectionStatus.Disconnected, async () => {
            const { playerData } = getOrCreatePlayer(guildId);
            if (playerData.isPlaying && playerData.lastVoiceChannel) {
                try {
                    // Intentar reconectar
                    playerData.connection = await connectToChannel(playerData.lastVoiceChannel, guildId);
                    playerData.connection.subscribe(playerData.player);
                } catch (error) {
                    console.error('[Music System] Error al reconectar:', error);
                    stopPlaying(guildId);
                }
            }
        });

        return connection;
    } catch (error) {
        connection.destroy();
        throw error;
    }
}

/**
 * Reproduce una canci√≥n
 * @param {Object} interaction - Interacci√≥n de Discord
 * @param {string} query - T√©rmino de b√∫squeda o URL
 */
async function playSong(interaction, query) {
    try {
        const { member, guildId } = interaction;
        
        if (!member.voice.channel) {
            throw new Error('¬°Necesitas estar en un canal de voz!');
        }

        const { playerData, queueData } = getOrCreatePlayer(guildId);
        playerData.lastVoiceChannel = member.voice.channel;

        // Si no hay conexi√≥n o est√° en un canal diferente, crear una nueva
        if (!playerData.connection || 
            playerData.connection.joinConfig.channelId !== member.voice.channel.id) {
            if (playerData.connection) {
                playerData.connection.destroy();
            }
            playerData.connection = await connectToChannel(member.voice.channel, guildId);
            playerData.connection.subscribe(playerData.player);
        }

        // Buscar la canci√≥n
        const songInfo = await searchSong(query);
        const track = {
            url: songInfo.url,
            title: songInfo.title,
            thumbnail: songInfo.snippet.thumbnails.high.url,
            duration: songInfo.duration_raw,
            requestedBy: member.user.tag
        };

        // A√±adir a la cola
        queueData.tracks.push(track);

        // Si no hay nada reproduci√©ndose, empezar a reproducir
        if (!playerData.isPlaying) {
            await startPlaying(interaction, guildId);
        } else {
            // Enviar mensaje de a√±adido a la cola
            const randomNote = EMOJIS.NOTES[Math.floor(Math.random() * EMOJIS.NOTES.length)];
            const embed = new EmbedBuilder()
                .setColor(COLORS.SUCCESS)
                .setTitle(`${EMOJIS.ADDED} A√±adido a la cola ${randomNote}`)
                .setDescription(`**${track.title}**`)
                .setThumbnail(track.thumbnail)
                .addFields(
                    { name: `${EMOJIS.TIME} Duraci√≥n`, value: track.duration, inline: true },
                    { name: `${EMOJIS.USER} Solicitado por`, value: track.requestedBy, inline: true }
                )
                .setFooter({ text: `Usa los controles debajo para gestionar la reproducci√≥n ${EMOJIS.VOLUME}` });

            const row = createControlButtons(playerData);
            await interaction.reply({ embeds: [embed], components: [row] });
        }
    } catch (error) {
        console.error('[Music System] Error al reproducir:', error);
        throw error;
    }
}

/**
 * Crea los botones de control
 * @param {Object} playerData - Datos del reproductor
 * @returns {ActionRowBuilder} Fila de botones
 */
function createControlButtons(playerData) {
    return new ActionRowBuilder()
        .addComponents(
            new ButtonBuilder()
                .setCustomId('music_pause_resume')
                .setLabel(playerData.player.state.status === 'playing' ? 'Pausar' : 'Reanudar')
                .setStyle(playerData.player.state.status === 'playing' ? ButtonStyle.Secondary : ButtonStyle.Success)
                .setEmoji(playerData.player.state.status === 'playing' ? EMOJIS.PAUSE : EMOJIS.PLAY),
            new ButtonBuilder()
                .setCustomId('music_skip')
                .setLabel('Saltar')
                .setStyle(ButtonStyle.Primary)
                .setEmoji(EMOJIS.SKIP),
            new ButtonBuilder()
                .setCustomId('music_stop')
                .setLabel('Detener')
                .setStyle(ButtonStyle.Danger)
                .setEmoji(EMOJIS.STOP),
            new ButtonBuilder()
                .setCustomId('music_queue')
                .setLabel('Ver Cola')
                .setStyle(ButtonStyle.Secondary)
                .setEmoji(EMOJIS.QUEUE),
            new ButtonBuilder()
                .setCustomId('music_leave')
                .setLabel('Salir')
                .setStyle(ButtonStyle.Danger)
                .setEmoji(EMOJIS.LEAVE)
        );
}

/**
 * Inicia la reproducci√≥n de la cola
 * @param {Object} interaction - Interacci√≥n de Discord
 * @param {string} guildId - ID del servidor
 */
async function startPlaying(interaction, guildId) {
    const { playerData, queueData } = getOrCreatePlayer(guildId);
    
    if (queueData.tracks.length === 0) {
        playerData.isPlaying = false;
        return;
    }

    const track = queueData.tracks.shift();
    queueData.currentTrack = track;
    playerData.isPlaying = true;

    try {
        const resource = await createYouTubeResource(track.url);
        playerData.player.play(resource);

        const randomNote = EMOJIS.NOTES[Math.floor(Math.random() * EMOJIS.NOTES.length)];
        const progressBar = `${EMOJIS.WAVE}${EMOJIS.WAVE}${EMOJIS.WAVE}${EMOJIS.WAVE}${EMOJIS.WAVE}`;

        const embed = new EmbedBuilder()
            .setColor(COLORS.PRIMARY)
            .setTitle(`${EMOJIS.NOW_PLAYING} Reproduciendo ahora ${randomNote}`)
            .setDescription(`**${track.title}**\n\n${progressBar}`)
            .setThumbnail(track.thumbnail)
            .addFields(
                { name: `${EMOJIS.TIME} Duraci√≥n`, value: track.duration, inline: true },
                { name: `${EMOJIS.USER} Solicitado por`, value: track.requestedBy, inline: true }
            )
            .setTimestamp()
            .setFooter({ text: `Usa los controles debajo para gestionar la reproducci√≥n ${EMOJIS.VOLUME}` });

        const row = createControlButtons(playerData);

        // Solo enviar mensaje si hay una interacci√≥n v√°lida
        if (interaction && !interaction.replied && !interaction.deferred) {
            const message = await interaction.reply({ embeds: [embed], components: [row] });
            queueData.nowPlayingMessage = message;
        } else if (queueData.nowPlayingMessage) {
            // Si ya hay un mensaje de "now playing", actualizarlo
            try {
                await queueData.nowPlayingMessage.edit({ embeds: [embed], components: [row] });
            } catch (error) {
                console.error('[Music System] Error al actualizar mensaje:', error);
            }
        }

        // Configurar eventos del reproductor
        playerData.player.once(AudioPlayerStatus.Idle, () => {
            playerData.isPlaying = false;
            if (queueData.tracks.length > 0) {
                startPlaying(null, guildId);
            }
        });
    } catch (error) {
        console.error('[Music System] Error al iniciar reproducci√≥n:', error);
        playerData.isPlaying = false;
        throw error;
    }
}

/**
 * Pausa la reproducci√≥n
 * @param {string} guildId - ID del servidor
 * @returns {boolean} True si se paus√≥ correctamente
 */
function pauseTrack(guildId) {
    const playerData = guildPlayers.get(guildId);
    if (playerData && playerData.player) {
        return playerData.player.pause();
    }
    return false;
}

/**
 * Reanuda la reproducci√≥n
 * @param {string} guildId - ID del servidor
 * @returns {boolean} True si se reanud√≥ correctamente
 */
function resumeTrack(guildId) {
    const playerData = guildPlayers.get(guildId);
    if (playerData && playerData.player) {
        return playerData.player.unpause();
    }
    return false;
}

/**
 * Salta a la siguiente canci√≥n
 * @param {string} guildId - ID del servidor
 */
function skipTrack(guildId) {
    const playerData = guildPlayers.get(guildId);
    if (playerData && playerData.player) {
        playerData.player.stop();
    }
}

/**
 * Detiene la reproducci√≥n y limpia la cola
 * @param {string} guildId - ID del servidor
 */
function stopPlaying(guildId) {
    const playerData = guildPlayers.get(guildId);
    const queueData = guildQueues.get(guildId);

    if (playerData) {
        if (playerData.connection) {
            playerData.connection.destroy();
            playerData.connection = null;
        }
        if (playerData.player) {
            playerData.player.stop();
        }
        playerData.isPlaying = false;
        playerData.lastVoiceChannel = null;
    }

    if (queueData) {
        queueData.tracks = [];
        queueData.currentTrack = null;
    }
}

/**
 * Obtiene la cola de reproducci√≥n
 * @param {string} guildId - ID del servidor
 * @returns {Object} Cola de reproducci√≥n
 */
function getQueue(guildId) {
    return guildQueues.get(guildId);
}

/**
 * Maneja los botones de control
 * @param {Object} interaction - Interacci√≥n de Discord
 */
async function handleButton(interaction) {
    try {
        const { customId, guildId } = interaction;
        const playerData = guildPlayers.get(guildId);

        if (!playerData || (!playerData.isPlaying && customId !== 'music_queue')) {
            return interaction.reply({ 
                content: '‚ùå ¬°No hay nada reproduci√©ndose!', 
                ephemeral: true 
            });
        }

        switch (customId) {
            case 'music_pause_resume':
                if (playerData.player.state.status === 'playing') {
                    if (pauseTrack(guildId)) {
                        await interaction.reply({ 
                            content: `${EMOJIS.PAUSE} M√∫sica pausada`, 
                            ephemeral: true 
                        });
                    }
                } else {
                    if (resumeTrack(guildId)) {
                        await interaction.reply({ 
                            content: `${EMOJIS.PLAY} M√∫sica reanudada`, 
                            ephemeral: true 
                        });
                    }
                }
                break;

            case 'music_skip':
                skipTrack(guildId);
                await interaction.reply({ 
                    content: `${EMOJIS.SKIP} Canci√≥n saltada`, 
                    ephemeral: true 
                });
                break;

            case 'music_stop':
                stopPlaying(guildId);
                await interaction.reply({ 
                    content: `${EMOJIS.STOP} Reproducci√≥n detenida`, 
                    ephemeral: true 
                });
                break;

            case 'music_leave':
                if (playerData.connection) {
                    playerData.connection.destroy();
                    playerData.connection = null;
                    playerData.lastVoiceChannel = null;
                    await interaction.reply({ 
                        content: `${EMOJIS.LEAVE} ¬°Hasta la pr√≥xima! ${EMOJIS.WAVE}`, 
                        ephemeral: true 
                    });
                }
                break;

            case 'music_queue':
                const queueData = getQueue(guildId);
                if (!queueData || (!queueData.currentTrack && queueData.tracks.length === 0)) {
                    return interaction.reply({ 
                        content: `${EMOJIS.ERROR} ¬°No hay canciones en la cola!`, 
                        ephemeral: true 
                    });
                }

                const randomNote = EMOJIS.NOTES[Math.floor(Math.random() * EMOJIS.NOTES.length)];
                const embed = new EmbedBuilder()
                    .setColor(COLORS.PRIMARY)
                    .setTitle(`${EMOJIS.QUEUE} Cola de Reproducci√≥n ${randomNote}`)
                    .setTimestamp();

                if (queueData.currentTrack) {
                    embed.addFields({
                        name: `${EMOJIS.NOW_PLAYING} Reproduciendo ahora:`,
                        value: `**${queueData.currentTrack.title}**\nSolicitado por: ${queueData.currentTrack.requestedBy}`
                    });
                }

                if (queueData.tracks.length > 0) {
                    const nextSongs = queueData.tracks
                        .slice(0, 10)
                        .map((track, index) => 
                            `${index + 1}. ${EMOJIS.NEXT} **${track.title}**\n${EMOJIS.USER} Solicitado por: ${track.requestedBy}`
                        )
                        .join('\n\n');

                    embed.addFields({
                        name: `${EMOJIS.QUEUE} Siguientes canciones:`,
                        value: nextSongs
                    });

                    if (queueData.tracks.length > 10) {
                        embed.setFooter({ 
                            text: `Y ${queueData.tracks.length - 10} canciones m√°s... ${EMOJIS.NOTES[Math.floor(Math.random() * EMOJIS.NOTES.length)]}` 
                        });
                    }
                }

                await interaction.reply({ embeds: [embed], ephemeral: true });
                break;
        }

        // Actualizar los botones si el mensaje a√∫n existe
        if (interaction.message && !interaction.message.ephemeral) {
            const row = createControlButtons(playerData);
            await interaction.message.edit({ components: [row] });
        }
    } catch (error) {
        console.error('[Music System] Error al procesar el bot√≥n:', error);
        await interaction.reply({ 
            content: '‚ùå ¬°Hubo un error al procesar el control!', 
            ephemeral: true 
        });
    }
}

export {
    playSong,
    pauseTrack,
    resumeTrack,
    skipTrack,
    stopPlaying,
    getQueue,
    handleButton,
    guildPlayers,
    guildQueues
}; 